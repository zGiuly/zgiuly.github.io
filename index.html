<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upload Labs Schematic viewer</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    
    <style>
        body, html {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: #212529;
        }

        #main-nav {
            position: relative;
            z-index: 10;
        }

        #canvas-wrapper {
            width: 100%;
            height: calc(100% - 56px);
            overflow: auto;
            cursor: grab;
            position: relative;
            background-image: linear-gradient(to right, #343a40 1px, transparent 1px), linear-gradient(to bottom, #343a40 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #schematic-container {
            position: relative;
            width: 8000px;
            height: 8000px;
            transform-origin: top left;
        }

        .window-node {
            position: absolute;
            min-width: 200px;
            user-select: none;
            border: 1px solid #0dcaf0;
            z-index: 10;
            box-shadow: 0 0 15px rgba(0, 202, 240, 0.2);
            background-color: #2c3034;
            transition: box-shadow 0.3s ease-in-out;
            cursor: pointer;
        }

        .window-node .card-header {
            cursor: move;
            padding: 0.5rem 1rem;
            font-weight: bold;
            text-transform: capitalize;
            background-color: #343a40;
            border-bottom: 1px solid #0dcaf0;
        }
        
        .window-node .card-body {
            padding: 0.75rem;
        }

        .port-container {
            padding: 4px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .port-label {
            padding-right: 15px;
            padding-left: 15px;
            font-size: 0.8rem;
        }

        .port {
            width: 14px;
            height: 14px;
            background-color: #0dcaf0;
            border-radius: 50%;
            border: 2px solid white;
            display: inline-block;
        }
        
        .jtk-connector path {
            stroke: #6ff0ff;
            stroke-width: 3;
            transition: stroke 0.3s ease-in-out, stroke-width 0.3s ease-in-out;
        }

        .jtk-connector.highlight-connector path {
            stroke: #ffc107;
            stroke-width: 5;
        }

        .jtk-endpoint {
            cursor: pointer;
        }
        
        #importModal .modal-body textarea {
            height: 40vh;
            font-family: monospace;
        }
        
        #summaryModal .modal-body {
            font-family: monospace;
            white-space: pre-wrap;
            background-color: #343a40;
            border-radius: 5px;
            padding: 15px;
            font-size: 1.1rem;
        }

        #toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1090;
        }

        .highlight-node {
            box-shadow: 0 0 25px 5px rgba(255, 255, 0, 0.7);
        }

        .search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/jsplumb@2.15.6/dist/js/jsplumb.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

</head>
<body class="bg-dark text-light">

    <!-- Navbar -->
    <nav id="main-nav" class="navbar navbar-expand-lg navbar-dark bg-dark border-bottom border-secondary">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Schematic Visualizer</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <div class="d-flex flex-column flex-lg-row align-items-lg-center ms-auto py-2">
                    <div id="search-container" class="position-relative mb-2 mb-lg-0 me-lg-3">
                        <form class="d-flex flex-column flex-lg-row" id="searchForm">
                            <input class="form-control w-100 me-lg-2 bg-dark text-light border-secondary mb-2 mb-lg-0" type="search" placeholder="Search Node..." aria-label="Search" id="searchInput">
                            <button class="btn btn-outline-primary w-100" type="submit">Search</button>
                        </form>
                    </div>
                    <button class="btn btn-outline-info me-2 mb-2 mb-lg-0" type="button" data-bs-toggle="modal" data-bs-target="#importModal">
                        Import
                    </button>
                    <button class="btn btn-outline-warning me-2 mb-2 mb-lg-0" type="button" id="summarizeBtn">
                        Summarize
                    </button>
                    <button class="btn btn-outline-primary me-2 mb-2 mb-lg-0" type="button" id="shareBtn">
                        Share
                    </button>
                    <button class="btn btn-outline-success mb-2 mb-lg-0" type="button" id="screenshotBtn">
                        Capture
                    </button>
                    <small class="text-warning fw-bold ms-2 mb-2 mb-lg-0">(Experimental)</small>
                </div>
            </div>
        </div>
    </nav>

    <!-- Canvas for the schematic -->
    <div id="canvas-wrapper">
        <div id="schematic-container">
            <div class="d-flex justify-content-center align-items-center h-50">
                <h3 class="text-muted">Click "Import Schematic" to load data.</h3>
            </div>
        </div>
    </div>

    <!-- Modal for JSON Import -->
    <div class="modal fade" id="importModal" tabindex="-1" aria-labelledby="importModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content bg-dark text-light">
                <div class="modal-header border-secondary">
                    <h5 class="modal-title" id="importModalLabel">Import Schematic Data</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p class="text-muted">Paste your schematic content (starting with `[schematic]`) into the text area below, or upload a .txt file.</p>
                    <textarea id="jsonInput" class="form-control bg-dark text-light border-secondary mb-3" rows="15" placeholder="[schematic]&#10;windows={...}&#10;connectors={...}"></textarea>
                    <input type="file" id="fileInput" accept=".txt" class="form-control bg-dark text-light border-secondary">
                    <div class="alert alert-danger mt-3 d-none" id="jsonError">Invalid format. Please check the console for more details.</div>
                </div>
                <div class="modal-footer border-secondary">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="loadJsonBtn">Load Schematic</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal for Summary -->
    <div class="modal fade" id="summaryModal" tabindex="-1" aria-labelledby="summaryModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content bg-dark text-light">
                <div class="modal-header border-secondary">
                    <h5 class="modal-title" id="summaryModalLabel">Schematic Summary</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="summaryBody">
                    <!-- Summary content will be injected here -->
                </div>
                <div class="modal-footer border-secondary">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container" class="toast-container"></div>

    <!-- Bootstrap 5 JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Application Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            
            const container = document.getElementById("schematic-container");
            const wrapper = document.getElementById('canvas-wrapper');
            const loadJsonBtn = document.getElementById('loadJsonBtn');
            const jsonInput = document.getElementById('jsonInput');
            const fileInput = document.getElementById('fileInput');
            const jsonError = document.getElementById('jsonError');
            const importModalEl = document.getElementById('importModal');
            const importModal = new bootstrap.Modal(importModalEl);
            const summarizeBtn = document.getElementById('summarizeBtn');
            const summaryModalEl = document.getElementById('summaryModal');
            const summaryModal = new bootstrap.Modal(summaryModalEl);
            const summaryBody = document.getElementById('summaryBody');


            let jsPlumbInstance = null;
            let currentSchematicData = null;
            let connectionsMap = new Map();
            let idToElementMap = new Map();

            function parseSchematicToObject(text) {
                const extractBlockContent = (key, rawText) => {
                    const blockStart = rawText.indexOf(key + "={");
                    if (blockStart === -1) return null;

                    const startIndex = blockStart + key.length + 2; 
                    let openBraces = 1;
                    
                    for (let i = startIndex; i < rawText.length; i++) {
                        if (rawText[i] === '{') openBraces++;
                        if (rawText[i] === '}') openBraces--;
                        if (openBraces === 0) {
                            return rawText.substring(startIndex, i);
                        }
                    }
                    return null;
                };

                const windowsContent = extractBlockContent("windows", text);
                const connectorsContent = extractBlockContent("connectors", text);

                if (windowsContent === null || connectorsContent === null) {
                    throw new Error("Could not find or parse 'windows' and 'connectors' blocks. Check for balanced curly braces {}.");
                }

                const cleanContentString = (content) => {
                    let cleaned = content.replace(/,\s*([}\]])/g, '$1');
                    cleaned = cleaned.replace(/Vector2\(([^,]+), ([^\)]+)\)/g, '{"x": $1, "y": $2}');
                    cleaned = cleaned.replace(/Array\[String\]\(([^)]*)\)/g, '$1');
                    return cleaned;
                };

                const finalJsonString = `{\n                    "windows": {${cleanContentString(windowsContent)}},\n                    "connectors": {${cleanContentString(connectorsContent)}}\n                }`;

                return JSON.parse(finalJsonString);
            }


            // --- HIGHLIGHTING LOGIC ---
            function clearAllHighlights() {
                document.querySelectorAll('.window-node.highlight-node').forEach(n => n.classList.remove('highlight-node'));
                document.querySelectorAll('.jtk-connector.highlight-connector').forEach(c => c.classList.remove('highlight-connector'));
            }

            function highlightNodeAndConnections(node) {
                clearAllHighlights();

                if (!node) return;

                node.classList.add('highlight-node');

                const portIds = Array.from(node.querySelectorAll('.port')).map(p => p.id);

                jsPlumbInstance.select().each(function(connection) {
                    if (portIds.includes(connection.sourceId) || portIds.includes(connection.targetId)) {
                        if (connection.connector.canvas) {
                            connection.connector.canvas.classList.add('highlight-connector');
                        }
                    }
                });
            }

            // --- MAIN RENDERING FUNCTION ---
            function renderSchematic(schematicData) {
                currentSchematicData = schematicData;
                container.innerHTML = '';
                if (jsPlumbInstance) jsPlumbInstance.reset();
                connectionsMap.clear();

                jsPlumbInstance = jsPlumb.getInstance({
                    Container: container,
                    Connector: ["Flowchart", { cornerRadius: 5, stub: 30 }],
                    Endpoint: "Blank"
                });

                const allWindows = Object.values(schematicData.windows);
                if (allWindows.length === 0) return;

                const xCoords = allWindows.map(w => w.position.x);
                const yCoords = allWindows.map(w => w.position.y);
                const minX = Math.min(...xCoords);
                const minY = Math.min(...yCoords);
                const offsetX = -minX + 100;
                const offsetY = -minY + 100;
                idToElementMap.clear();

                for (const [windowId, windowData] of Object.entries(schematicData.windows)) {
                    let title = windowData.window.replace(/_/g, ' ');
                    const windowNode = document.createElement('div');
                    windowNode.className = 'card window-node bg-dark text-light';
                    windowNode.id = windowId;
                    windowNode.style.left = (windowData.position.x + offsetX) + 'px';
                    windowNode.style.top = (windowData.position.y + offsetY) + 'px';

                    const cardHeader = document.createElement('div');
                    cardHeader.className = 'card-header';
                    cardHeader.textContent = title;
                    
                    const cardBody = document.createElement('div');
                    cardBody.className = 'card-body';
                    
                    windowNode.appendChild(cardHeader);
                    windowNode.appendChild(cardBody);

                    windowNode.addEventListener('click', (e) => {
                        if (!cardHeader.contains(e.target)) {
                            e.stopPropagation(); 
                            highlightNodeAndConnections(windowNode);
                        }
                    });

                    for (const [containerName, containerData] of Object.entries(windowData.container_data)) {
                        const portContainer = document.createElement('div');
                        portContainer.className = 'port-container';
                        const portLabel = document.createElement('span');
                        const labelText = containerName.split('/').pop();
                        portLabel.textContent = labelText;
                        portLabel.className = 'port-label';
                        const port = document.createElement('div');
                        port.className = 'port';
                        port.id = containerData.id;
                        idToElementMap.set(containerData.id, { element: port, data: containerData });
                        if (containerData.outputs_id && containerData.outputs_id.length > 0) {
                             portContainer.appendChild(portLabel);
                             portContainer.appendChild(port);
                        } else {
                             portContainer.appendChild(port);
                             portContainer.appendChild(portLabel);
                        }
                        cardBody.appendChild(portContainer);
                    }
                    container.appendChild(windowNode);
                }

                jsPlumbInstance.batch(() => {
                    for (const item of idToElementMap.values()) {
                        if (item.data.outputs_id && item.data.outputs_id.length > 0) {
                            const sourceId = item.data.id;
                            item.data.outputs_id.forEach(targetId => {
                                if (idToElementMap.has(targetId)) {
                                    const connection = jsPlumbInstance.connect({
                                        source: sourceId,
                                        target: targetId,
                                        anchors: ["Right", "Left"]
                                    });
                                    connectionsMap.set(`${sourceId}-${targetId}`, connection);
                                    connectionsMap.set(`${targetId}-${sourceId}`, connection);
                                }
                            });
                        }
                    }
                });
                
                jsPlumbInstance.draggable(document.querySelectorAll(".window-node"), { handle: ".card-header" });
            }

            // --- EVENT LISTENERS ---

            wrapper.addEventListener('click', (e) => {
                if (e.target === wrapper || e.target === container) {
                    clearAllHighlights();
                }
            });

            loadJsonBtn.addEventListener('click', () => {
                try {
                    jsonError.classList.add('d-none');
                    const schematicObject = parseSchematicToObject(jsonInput.value);
                    renderSchematic(schematicObject);
                    loadJsonBtn.blur(); 
                    importModal.hide();
                } catch (e) {
                    jsonError.textContent = e.message;
                    jsonError.classList.remove('d-none');
                    console.error("Failed to parse schematic data. Error:", e);
                }
            });

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        jsonInput.value = e.target.result;
                    };
                    reader.readAsText(file);
                }
            });

            shareBtn.addEventListener('click', async () => {
                if (!currentSchematicData) {
                    showToast("No schematic loaded to share.", "warning");
                    return;
                }

                try {
                    const jsonString = JSON.stringify(currentSchematicData);
                    const compressed = pako.deflate(jsonString);
                    const binaryString = Array.from(compressed, byte => String.fromCharCode(byte)).join('');
                    const base64Data = btoa(binaryString);
                    const shareUrl = `${window.location.origin}${window.location.pathname}#schematic_compressed=${base64Data}`;

                    await navigator.clipboard.writeText(shareUrl);
                    showToast('Share link copied to clipboard!');
                } catch (err) {
                    console.error('Failed to generate or copy share link:', err);
                    showToast('Failed to generate share link. See console.', 'danger');
                }
            });
            
            // --- SUMMARY LOGIC ---
            function generateShortSummary(schematicData) {
                if (!schematicData || !schematicData.windows) {
                    return "No data to summarize.";
                }

                const windows = Object.values(schematicData.windows);
                const totalNodes = windows.length;
                
                const typeCounts = windows.reduce((counts, windowData) => {
                    const nodeType = windowData.window
                        .replace(/_/g, ' ')
                        .replace(/\b\w/g, char => char.toUpperCase());
                    
                    counts[nodeType] = (counts[nodeType] || 0) + 1;
                    return counts;
                }, {});

                let summaryText = `Total nodes: ${totalNodes}\n\n`;
                const sortedTypes = Object.keys(typeCounts).sort();
                
                for (const type of sortedTypes) {
                    summaryText += `${type}: ${typeCounts[type]}\n`;
                }
                return summaryText;
            }

            summarizeBtn.addEventListener('click', () => {
                if (!currentSchematicData) {
                    showToast("No schematic loaded to summarize.", "warning");
                    return;
                }
                const summaryText = generateShortSummary(currentSchematicData);
                summaryBody.textContent = summaryText;
                summaryModal.show();
            });


            // --- Pan and Zoom Logic ---
            let isPanning = false;
            let startX, startY, scrollLeft, scrollTop;
            let scale = 1.0;
            let initialPinchDistance = 0;
            let lastScale = 1.0;
            let isPinching = false;

            const getDistance = (touch1, touch2) => {
                return Math.sqrt(Math.pow(touch2.pageX - touch1.pageX, 2) + Math.pow(touch2.pageY - touch1.pageY, 2));
            };

            const onPanStart = (e) => {
                if (e.target.closest('.window-node')) return;
                
                if (e.touches && e.touches.length === 2) {
                    isPinching = true;
                    initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
                    lastScale = scale;
                } else if (!e.touches || e.touches.length === 1) {
                    isPanning = true;
                    wrapper.style.cursor = 'grabbing';
                    const touch = e.touches ? e.touches[0] : e;
                    startX = touch.pageX - wrapper.offsetLeft;
                    startY = touch.pageY - wrapper.offsetTop;
                    scrollLeft = wrapper.scrollLeft;
                    scrollTop = wrapper.scrollTop;
                }
            };

            const onPanEnd = () => { 
                isPanning = false; 
                isPinching = false;
                wrapper.style.cursor = 'grab'; 
            };

            const onPanMove = (e) => {
                e.preventDefault();

                if (isPinching && e.touches && e.touches.length === 2) {
                    const currentPinchDistance = getDistance(e.touches[0], e.touches[1]);
                    const scaleFactor = currentPinchDistance / initialPinchDistance;
                    scale = Math.max(0.1, Math.min(2.0, lastScale * scaleFactor));
                    container.style.transform = `scale(${scale})`;
                    jsPlumbInstance.repaintEverything();
                } else if (isPanning && (!e.touches || e.touches.length === 1)) {
                    const touch = e.touches ? e.touches[0] : e;
                    const x = touch.pageX - wrapper.offsetLeft;
                    const y = touch.pageY - wrapper.offsetTop;
                    wrapper.scrollLeft = scrollLeft - (x - startX);
                    wrapper.scrollTop = scrollTop - (y - startY);
                }
            };

            wrapper.addEventListener('mousedown', onPanStart);
            wrapper.addEventListener('mouseup', onPanEnd);
            wrapper.addEventListener('mouseleave', onPanEnd);
            wrapper.addEventListener('mousemove', onPanMove);
            wrapper.addEventListener('touchstart', onPanStart);
            wrapper.addEventListener('touchend', onPanEnd);
            wrapper.addEventListener('touchcancel', onPanEnd);
            wrapper.addEventListener('touchmove', onPanMove);
            
            wrapper.addEventListener('wheel', (e) => {
                e.preventDefault();
                const mouseX = e.clientX - wrapper.getBoundingClientRect().left;
                const mouseY = e.clientY - wrapper.getBoundingClientRect().top;
                const contentMouseX = (wrapper.scrollLeft + mouseX) / scale;
                const contentMouseY = (wrapper.scrollTop + mouseY) / scale;
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                scale = Math.max(0.1, Math.min(2.0, scale + delta));
                container.style.transform = `scale(${scale})`;
                jsPlumbInstance.repaintEverything();
                const newScrollLeft = (contentMouseX * scale) - mouseX;
                const newScrollTop = (contentMouseY * scale) - mouseY;
                wrapper.scrollLeft = newScrollLeft;
                wrapper.scrollTop = newScrollTop;
            });

            // --- Screenshot Logic ---
            const screenshotBtn = document.getElementById('screenshotBtn');
            const toastContainer = document.getElementById('toast-container');

            function showToast(message, type = 'success') {
                const toastId = 'toast-' + Date.now();
                const toastHTML = `
                    <div id="${toastId}" class="toast align-items-center text-white bg-${type} border-0" role="alert" aria-live="assertive" aria-atomic="true">
                        <div class="d-flex">
                            <div class="toast-body">${message}</div>
                            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                        </div>
                    </div>`;
                toastContainer.insertAdjacentHTML('beforeend', toastHTML);
                const toastEl = document.getElementById(toastId);
                const toast = new bootstrap.Toast(toastEl, { delay: 3000 });
                toast.show();
                toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
            }

            screenshotBtn.addEventListener('click', async () => {
                const nodes = container.querySelectorAll('.window-node');
                if (nodes.length === 0) {
                    showToast("Nothing to capture.", "warning");
                    return;
                }
                const originalText = screenshotBtn.textContent;
                screenshotBtn.disabled = true;
                screenshotBtn.textContent = 'Generating...';
                let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
                nodes.forEach(node => {
                    const x = parseFloat(node.style.left);
                    const y = parseFloat(node.style.top);
                    const w = node.offsetWidth;
                    const h = node.offsetHeight;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x + w);
                    maxY = Math.max(maxY, y + h);
                });
                const padding = 100;
                const contentWidth = maxX - minX + (padding * 2);
                const contentHeight = maxY - minY + (padding * 2);
                const originalContainerWidth = container.style.width;
                const originalContainerHeight = container.style.height;
                const originalTransforms = new Map();
                container.style.width = `${contentWidth}px`;
                container.style.height = `${contentHeight}px`;
                nodes.forEach(node => {
                    originalTransforms.set(node, { left: node.style.left, top: node.style.top });
                    node.style.left = (parseFloat(node.style.left) - minX + padding) + 'px';
                    node.style.top = (parseFloat(node.style.top) - minY + padding) + 'px';
                });
                jsPlumbInstance.repaintEverything();
                await new Promise(resolve => setTimeout(resolve, 100));

                try {
                    const canvas = await html2canvas(container, {
                        scale: 2, backgroundColor: '#212529', width: contentWidth, height: contentHeight, x: 0, y: 0
                    });
                    canvas.toBlob(async (blob) => {
                        try {
                            await navigator.clipboard.write([ new ClipboardItem({ 'image/png': blob }) ]);
                            showToast('Screenshot copied to clipboard!');
                        } catch (err) {
                            console.error('Failed to copy to clipboard:', err);
                            showToast('Could not copy image. See console.', 'danger');
                        }
                    }, 'image/png');
                } catch (err) {
                    console.error('Screenshot failed:', err);
                    showToast('Could not generate screenshot. See console.', 'danger');
                } finally {
                    container.style.width = originalContainerWidth;
                    container.style.height = originalContainerHeight;
                    nodes.forEach(node => {
                        const original = originalTransforms.get(node);
                        node.style.left = original.left;
                        node.style.top = original.top;
                    });
                    jsPlumbInstance.repaintEverything();
                    setTimeout(() => {
                        screenshotBtn.disabled = false;
                        screenshotBtn.textContent = originalText;
                    }, 500);
                }
            });

            // --- Search Logic ---
            const searchForm = document.getElementById('searchForm');
            const searchInput = document.getElementById('searchInput');
            const searchContainer = document.getElementById('search-container');
            let searchDropdown = null;

            function removeSearchDropdown() {
                if (searchDropdown) {
                    searchDropdown.remove();
                    searchDropdown = null;
                }
            }

            function focusOnNode(node) {
                removeSearchDropdown();
                highlightNodeAndConnections(node);
                
                const scaledNodeLeft = node.offsetLeft * scale;
                const scaledNodeTop = node.offsetTop * scale;
                const scaledNodeWidth = node.offsetWidth * scale;
                const scaledNodeHeight = node.offsetHeight * scale;
                const targetScrollLeft = scaledNodeLeft + (scaledNodeWidth / 2) - (wrapper.offsetWidth / 2);
                const targetScrollTop = scaledNodeTop + (scaledNodeHeight / 2) - (wrapper.offsetHeight / 2);

                wrapper.scrollTo({
                    left: targetScrollLeft,
                    top: targetScrollTop,
                    behavior: 'smooth'
                });
            }

            searchForm.addEventListener('submit', (e) => {
                e.preventDefault();
                removeSearchDropdown();
                const searchTerm = searchInput.value.trim().toLowerCase();
                if (!searchTerm) {
                    clearAllHighlights();
                    return;
                }
                const allNodes = Array.from(container.querySelectorAll('.window-node'));
                const foundNodes = allNodes.filter(node => {
                    const header = node.querySelector('.card-header');
                    return header && header.textContent.toLowerCase().includes(searchTerm);
                });

                if (foundNodes.length === 1) {
                    focusOnNode(foundNodes[0]);
                } else if (foundNodes.length > 1) {
                    searchDropdown = document.createElement('div');
                    searchDropdown.className = 'list-group search-dropdown';
                    foundNodes.forEach(node => {
                        const item = document.createElement('button');
                        item.type = 'button';
                        item.className = 'list-group-item list-group-item-action bg-dark text-light';
                        item.textContent = node.querySelector('.card-header').textContent;
                        item.dataset.nodeId = node.id;
                        item.addEventListener('click', () => {
                            setTimeout(() => focusOnNode(node), 0);
                        });
                        searchDropdown.appendChild(item);
                    });
                    searchContainer.appendChild(searchDropdown);
                } else {
                    showToast(`Node "${searchInput.value}" not found.`, 'warning');
                }
            });

            document.addEventListener('click', (e) => {
                if (searchDropdown && !searchContainer.contains(e.target)) {
                    removeSearchDropdown();
                }
            });

            // --- Initial Load from URL Hash ---
            const loadSchematicFromHash = () => {
                const hash = window.location.hash;
                try {
                    let jsonString;
                    if (hash.startsWith('#schematic_compressed=')) {
                        const base64Data = hash.substring('#schematic_compressed='.length);
                        const binaryString = atob(base64Data);
                        const compressed = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            compressed[i] = binaryString.charCodeAt(i);
                        }
                        jsonString = pako.inflate(compressed, { to: 'string' });
                    } else if (hash.startsWith('#schematic=')) {
                        const base64Data = hash.substring('#schematic='.length);
                        jsonString = atob(base64Data);
                    }
                    if (jsonString) {
                        const schematicObject = JSON.parse(jsonString);
                        renderSchematic(schematicObject);
                        const initialMessage = container.querySelector('h3');
                        if (initialMessage) initialMessage.remove();
                    }
                } catch (e) {
                    console.error("Failed to load schematic from URL hash:", e);
                    showToast("Failed to load schematic from URL. Invalid data.", "danger");
                }
            };
            loadSchematicFromHash();
        });
    </script>
</body>
</html>